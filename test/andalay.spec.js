describe('Andalay:', function(){
	
	var OutcomeModel;
	var OutcomeCollection;
	var Contacts;
	var outcome;
	var $httpBackend;

	//var $httpBackend, $q, Andalay, OutcomeModel, OutcomeCollection;
	beforeEach(angular.mock.module('Andalay'));

	beforeEach(inject(function(_$httpBackend_, _$q_, _Andalay_){

		$httpBackend = _$httpBackend_;
		$q = _$q_;
		Andalay = _Andalay_;

		OutcomeModel = Andalay.Model.extend({
		    defaults:{
		    	label:'NO LABEL',
		        notes:'',
		        data:{},
		        definition:{},
		        another:'hi',
		    },
		    urlRoot: '/outcome',
		    getName: function(){
		        return this.id + ' ' + this.label;
		    }
		});

		OutcomeCollection = Andalay.Collection.extend({
		    model: OutcomeModel,
		    url: '/outcome',
		});

	}));

	afterEach(function(){
		// $httpBackend.verifyNoOutstandingExpectation();
		// $httpBackend.verifyNoOutstandingRequest();
	});

	/*****************************************************************************
	* CONFIGURATION
	*****************************************************************************/

	// describe('Creating Andalay',function(){
	// 	it('should be injectable',inject(function(Andalay){
	// 		expect(Andalay).toBeDefined();
	// 	}));
	// 	it('should have a valid Andalay.Collection object',inject(function(Andalay){
	// 		expect(Andalay.Collection).toBeDefined();
	// 		expect(angular.isFunction(Andalay.Collection.extend)).toBeTruthy();
	// 	}));
	// 	it('should have a valid Andalay.Model model object',inject(function(Andalay){
	// 		expect(Andalay.Model).toBeDefined();
	// 		expect(angular.isFunction(Andalay.Model.extend)).toBeTruthy();
	// 	}));
	// }))

	// test that we can reset a collection
	describe('Test Andalay collection',function(){

		it('should be defined', function(){
			outcome = new OutcomeCollection();
			expect(outcome).toBeDefined();
			expect(outcome.models).toBeEmptyArray();
		})

		it('should contain an array of models', function(){
			outcome.reset(resetData());
			expect(outcome.models).toBeArrayOfObjects();
			expect(outcome.models.length).toEqual(8);
			expect(outcome.models[0]).toHaveMethod('getName');
		});

		it('should have overriden default properties', function(){
			// the model with id 0 has no label attribute defined,
			// so it should be populated by the default label attribute in the defaults property
			expect(outcome.get(0).getName()).toEqual('0 NO LABEL');
			expect(outcome.get('nocontact').getName()).toEqual('nocontact No Contact');
		})

		it('should be possible to get models by id', function(){
			// It should be possible to get models from the collection by:
			expect(outcome.get('nocontact').label).toEqual('No Contact');
			expect(outcome.get({id:'nocontact'}).label).toEqual('No Contact');
		})

		it('should be possible to get models by autogenerated cid', function(){
			// It should be possible to get models from the collection by:
			var nocontact = outcome.models[1];
			expect(outcome.get(nocontact.cid).label).toEqual('No Contact');
			expect(outcome.get({cid:nocontact.cid,other:'random'}).label).toEqual('No Contact');
		})
		
		// Functions to test:

		// collection.add
		it('should add a model', function(){
			var toadd = {label:'newly added'};
			var model = outcome.addOne(toadd);
			expect(model.label).toEqual('newly added');
			expect(outcome.get(model).id).toBeUndefined();
			expect(model.getName()).toEqual('undefined newly added');
			expect(outcome.length).toEqual(9);
			expect(outcome.models.length).toEqual(9);
			expect(outcome.get(model).cid).toEqual('c9');
		})

		// collection.add 
		it('should throw an error when attempting to call addOne with invalid model param', function(){
			var undefinedVar;
			expect(function(){outcome.addOne(undefinedVar)}).toThrow(new Error('Cannot add "'+undefinedVar+'" to the collection. You must specify an object to add'));
			expect(function(){outcome.addOne()}).toThrow(new Error('Cannot add "undefined" to the collection. You must specify an object to add'));
			expect(function(){outcome.addOne([])}).toThrow(new Error('The object to add must be an object. Array given'));
		})

		// collection.addMany
		it('should throw an error when callinfg addMany with models param', function(){
			expect(function(){outcome.addMany()}).toThrow(new Error('Cannot add undefined, models must be an array of objects'));
			expect(function(){outcome.addMany({})}).toThrow(new Error('Cannot add [object Object], models must be an array of objects'));
		})
		
		// collection.addOne
		it('should add one model', function(){
			var toadd = {label:'last added'};
			var model = outcome.addOne(toadd);
			expect(model.label).toEqual('last added');
			expect(outcome.get(model).id).toBeUndefined();
			expect(model.getName()).toEqual('undefined last added');
			expect(outcome.length).toEqual(10);
			expect(outcome.models.length).toEqual(10);
			expect(outcome.get(model).cid).toEqual('c10');
		})

		// collection.updateOne
		it('should update a models attributes', function(){
			var moved = outcome.get('movedhouse');
			var returnedModel = outcome.update({id:'movedhouse', label:'Moved House Indeed!'});
			expect(outcome.get('movedhouse').label).toEqual('Moved House Indeed!');
			expect(returnedModel.label).toEqual('Moved House Indeed!');
			expect(moved.label).toEqual('Moved House Indeed!');
		})

		// collection.remove
		it('should remove a model', function(){
			var removed = outcome.remove({id:'movedhouse'});
			expect(outcome.length).toEqual(9);
			var checkNotFound = outcome.get('movedhouse');
			expect(checkNotFound).toBeUndefined();
			expect(removed).toBeObject();
			expect(removed.id).toEqual('movedhouse');
			expect(removed.getName()).toEqual('movedhouse Moved House Indeed!');
		})

        // modelId

        // last
        it('should return the last model in the collection', function(){
        	var last = outcome.last();
        	expect(last.getName()).toEqual('undefined last added');
        })

        // at
        it('should return a model at position specified', function(){
        	var one = outcome.at(1);
        	expect(one.id).toEqual('nocontact');
        })

        // size
        it('should return the collection size', function(){
        	var size = outcome.size();
        	expect(size).toEqual(9);
        })

        // all
        it('should return all models', function(){
        	var all = outcome.all();
        	expect(all).toBeArray();
        	expect(all.length).toEqual(9);
        })

        // removeAll
        it('modelId function should return the id', function(){
        	var nocontact = outcome.get('nocontact');
        	var id = outcome.modelId({id:123})
        	expect(id).toEqual(123);
        })

        // toJSON
        it('should return array when calling toJSON method', function(){
        	var json = outcome.toJSON();
        	expect(json).toBeArray();
        	expect(json[0].collection)
        })

        it('should remove the collection reference from the returned model when toJSON is called', function(){
        	var json = outcome.toJSON();
        	expect(json[0].collection).toBeUndefined();
        })

        // removeAll
        it('should remove all', function(){
        	outcome.removeAll();
        	expect(outcome.models).toBeEmptyArray();
        })

        // idAttribute
        it('should work with a custom id attribute of _id', function() {
        	var ContactModel = Andalay.Model.extend({
        		idAttribute:'_id',
        		url: 'contact',
        	});
        	var ContactCollection = Andalay.Collection.extend({
        		model:ContactModel
        	});
        	Contacts = new ContactCollection();
        	Contacts.reset([
        		{
        			_id:100,
        			name:'Andrew'
        		},
        		{
        			_id:123,
        			name:'Bob'
        		},
        		{
        			_id:102,
        			name:'Chris'
        		}
        	]);
        	var bob = Contacts.get(123);
        	var andrew = Contacts.get({_id:100});
        	expect(bob.name).toEqual('Bob');
        	expect(andrew.name).toEqual('Andrew');
        });

        it('should get a collection from the server', function() {
   			outcomeCollection = new OutcomeCollection();
			outcomeCollection.fetch().then(function() {
				expect(outcomeCollection.models[2].parent).toBe('nocontact');
			}, function(err) {
				console.log('err', err);
			});
			$httpBackend.expectGET('/outcome').respond(200, resetData());
			$httpBackend.flush();
        });
        
		it('should get a collection from the server and parse a nonstandard response correctly', function() {
   			OutcomeCollection = Andalay.Collection.extend({
			    model: OutcomeModel,
			    url: '/outcome',
			    parse: function(response, options) {
			    	return response.models;
			    }
			});
   			outcomeCollection = new OutcomeCollection();
			outcomeCollection.fetch().then(function() {
				expect(outcomeCollection.models[2].parent).toBe('nocontact');
			}, function(err) {
				console.log('err', err);
			});
			$httpBackend.expectGET('/outcome').respond(200, {models: resetData()});
			$httpBackend.flush();
        });
	});

	describe('Test Andalay model', function() {
		it('should find a model', function(){
        	var person = Contacts.find(function(model) { return model.name == 'Bob' });
        	expect(person.name).toBe('Bob');
        });

        it('should filter a model', function(){
        	var people = Contacts.filter(function(model) { return (model.name == 'Bob' || model.name == 'Chris') });
        	expect(people[0].name).toBe('Bob');
        	expect(people[1].name).toBe('Chris');
        });

        it('should filter a model with .where', function(){
        	var person = Contacts.where({'name': 'Bob'});
        	expect(person[0].name).toBe('Bob');
        	var person = Contacts.where({'name': 'Bob'}, true);
        	expect(person.name).toBe('Bob');
        });

        it('should filter a model with .findWhere', function(){
        	var person = Contacts.findWhere({'name': 'Bob'});
        	expect(person.name).toBe('Bob');
        });

        it('should save a model to the server, and update the client side model', function(){
        	// This isn't correct - the POST should be mirroring the data,
        	// already defined in the model. Boo urns, rewrite it.
        	outcomeModel = new OutcomeModel(resetModelData());
			outcomeModel.save().then(function() {
				expect(outcomeModel.id).toBe('nocontact');
			}, function(err) {
				console.log('err', err);
			});
			$httpBackend.expectPUT('/outcome/nocontact').respond(200,resetModelData());
			$httpBackend.flush();
        });

        it('should fetch a single model from the server', function(){
        	outcomeModel = new OutcomeModel({id: 'nocontact'});
        	outcomeModel.fetch().then(function(response) {
        		expect(outcomeModel.label).toBe('No Contact');
        	});
			$httpBackend.expectGET('/outcome/nocontact').respond(200,resetModelData());
			$httpBackend.flush();
        });

        it('should delete a single model from the server', function(){
        	outcomeModel = new OutcomeModel(resetModelData());
        	outcomeModel.delete().then(function(response) {
        		expect(outcomeModel.id).toBe(null);
        	});
			$httpBackend.expectDELETE('/outcome/nocontact').respond(203);
			$httpBackend.flush();
        });

        it('should delete a model from the server and remove that model from its collection', function(){
        	outcomeCollection = new OutcomeCollection();
        	outcomeModel = new OutcomeModel(resetModelData());
        	outcomeCollection.addOne(outcomeModel);
        	expect(outcomeCollection.get('nocontact').label).toBe('No Contact');
        	outcomeModel.delete().then(function(response) {
        		expect(outcomeModel.id).toBe(null);
        		expect(outcomeCollection.get('nocontact')).toBe(void 0);
        	});
			$httpBackend.expectDELETE('/outcome/nocontact').respond(203);
			$httpBackend.flush();
        });
	});

	describe('Replicate addOne bug', function() {
		it('should set up new models', function(){
			var DonationModel = Andalay.Model.extend({
				defaults:{type:'unknown'}
			});
			var DonationCollection = Andalay.Collection.extend({
	    		model:DonationModel
			});
			var donations = new DonationCollection();
			var donation = {type:'my new type'};
			donations.addOne(donation);
		});
	});

	// Replicate a bug where the default properties get shared between models
	describe('Defaults should not be shared', function() {
		// Defaults should be different!
		// TODO: write a test to make sure default properties are not getting global 
		// references and are updated uniquely per model
		it('setting a property that has already been defined as default, should not result in shared value', function() {
			//throw new Error('implement me');
			var TaskModel = Andalay.Model.extend({
				defaults:{
					name:'no name defined',
					type:'task'
				}
			});
			var TaskCollection = Andalay.Collection.extend({
	    		model:TaskModel
			});
			var tasks = new TaskCollection();
			var task = new TaskModel({id: 1, name: 'A new task'});
			var job = new TaskModel({id: 2, name: 'A new Job', type: 'job'});
			tasks.addMany([task, job]);
			expect(tasks.get(1).type).toEqual('task');
			expect(tasks.get(2).type).toEqual('job');
			//TODO: integrate with angular scope, as it is when angular updates its scope
			// that the refernce to defaults property can break.
		});
	});
});

function resetData(){
	return [
		{
			id: 0,
			parent: null,
			type: 'group',
			description: null,
			children: ['notcontact', 'callback', 'refusal']
		},
		{
			id: 'nocontact',
			parent: 0,
			type: 'group',
			label: 'No Contact',
			description: 'Heres the description for no contact group',
			children: ['deceased', 'movedhouse', 'businessnumber', 'faxnumber']
		},
		{
			id: 'deceased',
			parent: 'nocontact',
			type:'outcome',
			label: 'Deceased',
			description: 'Description goes here'
		},
		{
			id: 'movedhouse',
			parent: 'nocontact',
			type:'outcome',
			label: 'Moved House',
			description: 'Description goes here'
		},
		{
			id: 'businessnumber',
			parent: 'nocontact',
			type:'outcome',
			label: 'Business Number',
			description: 'Description goes here'
		},
		{
			id: 'faxnumber',
			parent: 'nocontact',
			type:'outcome',
			label: 'Fax Number',
			description: 'Description goes here'
		},
		{
			id: 'forms',
			parent: 0,
			type: 'outcome',
			label: 'Forms',
			description: 'Description goes here for forms'
		},
		{
			id: 'donation',
			parent: 0,
			type:'outcome',
			label: 'Donations',
			description: 'Description goes here for donations'
		}
	];
}

function resetModelData() {
	return {
		id: 'nocontact',
		parent: 0,
		type: 'group',
		label: 'No Contact',
		description: 'Heres the description for no contact group',
		children: ['deceased', 'movedhouse', 'businessnumber', 'faxnumber']
	};
}